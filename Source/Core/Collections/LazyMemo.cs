using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Core.Monads;

namespace Core.Collections;

public class LazyMemo<TKey, TValue> : IDictionary<TKey, TValue>, IHash<TKey, TValue> where TKey : notnull where TValue : notnull
{
   protected Hash<TKey, TValue> hash;
   protected Func<TKey, Maybe<TValue>> defaultValue;

   public LazyMemo(Hash<TKey, TValue> hash, Func<TKey, Maybe<TValue>> defaultValue)
   {
      this.hash = hash;
      this.defaultValue = defaultValue;
   }

   public LazyMemo(Func<TKey, Maybe<TValue>> defaultValue) : this([], defaultValue)
   {
   }

   public void Add(TKey key, TValue value)
   {
      this[key] = value;
   }

   public bool ContainsKey(TKey key) => hash.ContainsKey(key);

   public Hash<TKey, TValue> GetHash() => hash;

   public HashInterfaceMaybe<TKey, TValue> Items => new(hash);

   public bool Remove(TKey key) => hash.Remove(key);

   public bool TryGetValue(TKey key, [MaybeNullWhen(false)] out TValue value)
   {
      if (hash.Maybe[key] is (true, var actualValue))
      {
         value = actualValue;
         return true;
      }
      else
      {
         value = default;
         return false;
      }
   }

   public TValue this[TKey key]
   {
      get
      {
         if (hash.Maybe[key] is (true, var value))
         {
            return value;
         }
         else
         {
            var _value = defaultValue(key);
            if (_value is (true, var newValue))
            {
               hash[key] = newValue;
               return newValue;
            }
            else
            {
               throw new ArgumentException("Value couldn't be generated by given function");
            }
         }
      }
      set => hash[key] = value;
   }

   internal void ForceValue(TKey key)
   {
      if (!hash.Maybe[key])
      {
         var _value = defaultValue(key);
         if (_value is (true, var value))
         {
            hash[key] = value;
         }
      }
   }

   public ICollection<TKey> Keys => hash.Keys;

   public ICollection<TValue> Values => hash.Values;

   public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
   {
      foreach (var key in Keys)
      {
         yield return new KeyValuePair<TKey, TValue>(key, this[key]);
      }
   }

   IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

   public void Add(KeyValuePair<TKey, TValue> item) => this[item.Key] = item.Value;

   public void Clear() => hash.Clear();

   public bool Contains(KeyValuePair<TKey, TValue> item) => hash.ContainsKey(item.Key);

   public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex) => ((IDictionary<TKey, TValue>)hash).CopyTo(array, arrayIndex);

   public bool Remove(KeyValuePair<TKey, TValue> item) => hash.Remove(item.Key);

   public int Count => hash.Count;

   public bool IsReadOnly => false;

   public LazyMemoMaybe<TKey, TValue> Maybe => new(this);
}